# Системні виклики в UNIX/POSIX (файлові операції, fork(), qsort(), write(), read(), lseek()

## Зміст
- [Завдання 1: Частковий запис у pipe](#завдання-1-частковий-запис-у-pipe)
- [Завдання 2: Читання з файлу після lseek](#завдання-2-читання-з-файлу-після-lseek)
- [Завдання 3: Аналіз продуктивності та тестування коректності qsort](#завдання-3-аналіз-продуктивності-та-тестування-коректності-qsort)
- [Завдання 4: Використання fork](#завдання-4-використання-fork)
- [Завдання 5: Атомарний обмін файлів](#завдання-5-атомарний-обмін-файлів)

---

## Завдання 1: Частковий запис у pipe

### Опис
Дослідження поведінки системного виклику `write()` для можливості повернення кількості записаних байтів, меншої за запитану.

### Результати
  ```
  Requested write: 100000 bytes
  Actually written: 65536 bytes
  ```

### Пояснення
- Програма створює pipe і встановлює write-end у неблокуючий режим (`O_NONBLOCK`) за допомогою `fcntl()`.
- Спроба записати 100000 байтів у pipe завершується частковим записом через обмеження розміру буфера pipe (зазвичай 65536 байтів у UNIX).
- У неблокуючому режимі `write()` записує лише стільки даних, скільки може вмістити буфер, і повертає їх кількість, що дозволяє продемонструвати повернення значення, меншого за запитане.

### Висновки
- Системний виклик `write()` може повертати менше байтів, ніж запитано, якщо буфер заповнений або є інші обмеження.
- Використання неблокуючого режиму дозволяє уникнути блокування програми та дослідити поведінку pipe.

## Завдання 2: Читання з файлу після lseek

### Опис
Аналіз поведінки системних викликів `lseek()` і `read()` при роботі з файлом, що містить задану послідовність байтів.

### Результати
  ```
  Зчитано 4 байтів: 2 3 3 7
  ```

### Пояснення
- Програма створює файл `data.bin` із послідовністю байтів: `[4, 5, 2, 2, 3, 3, 7, 9, 1, 5]`.
- Виклик `lseek(fd, 3, SEEK_SET)` переміщує вказівник файлу на позицію 3 (четвертий байт, значення 2).
- Виклик `read(fd, buffer, 4)` зчитує 4 байти з позиції 3: `[2, 3, 3, 7]`.

### Висновки
- Виклик `lseek()` дозволяє точно позиціонувати вказівник у файлі для подальшого читання.
- `read()` зчитує задану кількість байтів із поточної позиції.

## Завдання 3: Аналіз продуктивності та тестування коректності qsort

### Опис
Дослідження продуктивності функції `qsort` для різних типів вхідних даних, щоб визначити найгірші випадки роботи алгоритму швидкого сортування. Перевірка коректності роботи функції `qsort` за допомогою набору тестів із різними масивами.

### Результати
  ```
  Відсортований масив: 0.117188 секунд
  Зворотньо відсортований масив: 0.148438 секунд
  Масив з однаковими елементами: 0.046875 секунд
  Випадковий масив: 1.507812 секунд
  ```
  ```
  Тест 1 (порожній): Пройдено
  Тест 2 (один елемент): Пройдено
  Тест 3 (два елементи): Пройдено
  Тест 4 (відсортований): Пройдено
  Тест 5 (зворотній): Пройдено
  Тест 6 (дублікати): Пройдено
  Тест 7 (випадковий): Пройдено
  ```

### Пояснення
- Програма тестує `qsort` на масивах розміром 10,000,000 елементів із чотирма типами даних: відсортованим, зворотно відсортованим, усіма однаковими елементами та випадковим.
- Найшвидший випадок — масив із однаковими елементами, оскільки порівняння тривіальні.
- Випадковий масив займає найбільше часу через велику кількість порівнянь і перестановок.
- Відсортований і зворотно відсортований масиви також відносно швидкі завдяки оптимізаціям у сучасних реалізаціях `qsort`.
- Програма перевіряє `qsort` на семи тестових масивах: порожньому, з одним елементом, із двома елементами, відсортованому, зворотно відсортованому, із дублікатами та випадковому.
- Функція `is_sorted()` перевіряє, чи масив відсортований у зростаючому порядку після виклику `qsort`.
- Усі тести пройдено.

### Висновки
- Продуктивність `qsort` залежить від структури вхідних даних.
- Сучасні реалізації `qsort` (наприклад, у glibc) використовують оптимізації, які зменшують вплив найгірших випадків, таких як відсортовані масиви.
- Функція `qsort` коректно обробляє масиви різного розміру та структури, включаючи крайні випадки (порожній масив, дублікати).

## Завдання 4: Використання fork

### Опис
Аналіз поведінки системного виклику `fork()` і його впливу на виконання програми.

### Результати
- Виведено два значення: PID дочірнього процесу та 0.
  ```
  1635
  0
  ```

### Пояснення
- Програма викликає `fork()`, який створює дочірній процес.
- У батьківському процесі `fork()` повертає PID дочірнього процесу (наприклад, 1635), а в дочірньому — 0.
- Обидва процеси виконують `printf()`, тому виводяться два значення.
- Порядок виводу залежить від планувальника процесів.

### Висновки
- Виклик `fork()` ефективно створює копію процесу, дозволяючи паралельне виконання.
- Різні повернені значення дозволяють розрізняти батьківський і дочірній процеси.

## Завдання 5: Атомарний обмін файлів

### Опис
Реалізація утиліти для атомарного обміну вмістом двох файлів без створення тимчасових файлів із новим вмістом.

### Результати
  ```
  ./task5 first.txt second.txt
  Обмін виконано успішно
  ```

### Пояснення
- Програма використовує системний виклик `rename()` для послідовного перейменування файлів:
  - `file1` перейменовується у тимчасове ім’я (`temp_swap`).
  - `file2` перейменовується у `file1`.
  - `temp_swap` перейменовується у `file2`.
- Виклик `rename()` є атомарним у межах однієї файлової системи.
- У разі помилки на будь-якому кроці виконується відкат (повернення `temp_swap` до `file1`).

### Висновки
- Використання `rename()` дозволяє ефективно обмінювати файли без створення тимчасових копій їхнього вмісту.
- Програма обробляє помилки, забезпечуючи надійність операції.
